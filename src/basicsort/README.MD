# 기본 정렬
알고리즘을 공부할때 가장 먼서 시작하는 파트가 `정렬(Sort)` 이다.  
왜냐하면 정렬만큼 알고리즘의 효율성 차이를 가장 직관적으로 보여주는 것이 없기 때문이다.  
여기서는 가장 기본적인 정렬들을 다루겠다.  

>   1. [선택정렬](https://github.com/kujaHn/Algorithm/tree/main/src/basicsort#1-선택정렬)
>   2. 버블정렬
>   3. 삽입정렬
>   4. 퀵정렬
>   5. 병합정렬
## Question.
다음 숫자를 오름차순으로 정렬하는 프로그램을 작성하시오.
```
[1 10 3 6 4 7 9 8 2 5]
```

## Solutions.
### 1. 선택정렬
이러한 케이스에서 가장 쉽게 접근할 수 있는 방법이 `선택정렬`이다.

선택정렬의 특징은 다음과 같다.  
* 데이터의 양이 적을때 준수한 성능을 나타냄
* 데이터가 조금만 많아져도 연산속도가 확 느려짐.
* 시간복잡도
    ```
    10 + 9 + 8 + ... + 1
    N * (N + 1) / 2 ==> O(N^2)  
    ```

### 로직
**1st**  
먼저 전체 숫자를 읽어서 가장 작은 수를 제일 앞으로 보낸다.  
여기서는 1이 이미 첫번째 이기 떄문에 넘어간다.
```
[1 10 3 6 4 7 9 8 2 5]
```

**2nd**  
맨 앞을 제외하고 나머지 `10 3 6 4 7 9 8 2 5` 중 **가장 작은 수를 제일 앞의 원소와 자리를 바꾼다.** 
```
[1 2 3 6 4 7 9 8 10 5]
```

**3rd**  
1과 2를 제외하고 나머지 `3 6 4 7 9 8 10 5` 중 **가장 작은 수를 제일 앞의 원소와 자리를 바꾼다.**
```
[1 2 3 6 4 7 9 8 10 5]
```

**4th**  
이 과정을 `반복`한다.
```
[1 2 3 4 5 6 7 8 9 10]
```
<br>

이 로직에서 중요한 것은 내가 `찾는 범위`에서 `가장 작은 수`를 찾아 그 범위의 `제일 앞의 원소`와 `자리를 바꾸는 것`을 `반복` 하는 것이다.
  
코드를 구현해 보자.
```
    public int[] selectionSort(int[] array) {
        int minIndex;
        int temp;

        // 찾는 범위 설정
        for (int i = 0; i < array.length-1; i++) {
            minIndex = i;
            // 가장 작은 수 탐색
            for (int j = i; j < array.length; j++) {
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            // 스와핑
            temp = array[i];
            array[i] = array[minIndex];
            array[minIndex] = temp;
        }
        return array;
    }
```
***
### 2. 버블정렬
**바로 옆의 숫자와 비교해서 더 큰 값을 뒤로 보내는 방법**을 `버블정렬`이라고 한다.  
버블정렬의 특징은 다음과 같다.
* 정렬 중 가장 효율이 안좋음
* 시간복잡도
    ```
    10 + 9 + 8 + ... + 1
    N * (N + 1) / 2 ==> O(N^2)  
    ```

### 로직
**1st**  
`1`과 `10`을 비교해서 더 작은 `10`을 뒤 옮긴다.
```
[1 10 3 6 4 7 9 8 2 5]
```

**2nd**  
`10`과 `3`를 비교해서 더 작은 `10`을 뒤로 옮긴다.
```
[1 3 10 6 4 7 9 8 2 5]
```

**3rd**  
`10`과 `6`을 비교해서 더 작은 `10`을 뒤으로 옮긴다.
```
[1 3 6 10 4 7 9 8 2 5]
```

**4th**  
가장 큰 값이 `제일 오른쪽`으로 이동했을 때 이 과정을 `반복`한다.
```
[1 3 6 4 7 9 8 2 5 10]
```
배열의 크기만큼 반복
```
[1 2 3 4 5 6 7 8 9 10]
```
<br>


코드를 구현해 보자.
```
public int[] bubbleSort(int[] array) {
        int max;
        int maxIndex;
        int temp;

        // 전체의 반복
        for (int i = 0; i < array.length; i++) {
            maxIndex = i;
            // 숫자를 비교하는 구간
            for (int j = 0; j < array.length -1 - i; j++) {
                if (array[j] > array[j+1]) {
                    // 스와핑
                    temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                }
            }
        }
        return array;
    }
```
***
### 3. 삽입정렬
* **각 단계마다 처음부터 그 해당 원소까지 정렬을 확실하게 한 후** 다음 숫자로 넘어가는 방식.  
* 단계들을 생략해서 보면 `원소 사이` 중 적절한 위치에 `삽입`하는 방식처럼 보여 `삽입방식`이라고 한다. 
* `해당 엘리먼트`가 `자신이 있어야하는 위치를 정확하게 알고 있다`는 것이 특징이다.
* 거의 정렬이 다 된 배열을 정렬할 때 가장 큰 효율을 낸다.
  
* O(N^2)중 가장 효율적임
  * 그때그때 정렬을 끝내, 두번 정렬을 해야할 필요없이 숫자를 삽입만 해주면 되기 떄문.
* 시간복잡도
    ```
    10 + 9 + 8 + ... + 1
    N * (N + 1) / 2 ==> O(N^2)  
    ```

### 로직
**1st**  
* `1`과 `10`을 비교. => 정렬이 이미 되어있기 떄문에 그대로 넘어가면 된다.
```
1 10 3 6 4 7 9 8 2 5
```

**2nd**  
* `10`과 `3`을 비교. => `3`이 `10` 앞으로 온다.
```
전
[1 10 3 6 4 7 9 8 2 5]
```
```
후
[1 3 10 6 4 7 9 8 2 5]
```

**3rd**  
* 1st. `10`과 `6`을 비교. => `6`이 `10` 앞으로 온다.  
* 2nd. `6`과 `3`을 비교 => 정렬이 이미 되어있기 떄문에 그대로 넘어가면 된다.
```
1st : 10, 6 위치 변경
[1 3 6 10 4 7 9 8 2 5]
```
```
2nd : OK
[1 3 6 10 4 7 9 8 2 5]
```

**4th**  
* 1st. `10`과 `4`를 비교. => `4`가 `10` 앞으로 온다.
* 2nd. `6`과 `4`를 비교. => `4`가 `6` 앞으로 온다.
* 3rd. `4`와 `3`을 비교. => 정렬이 이미 되어있기 떄문에 그대로 넘어가면 된다.
```
1st : 10, 4 위치 변경
[1 3 6 4 10 7 9 8 2 5]
```
```
2nd : 6, 4 위치 변경
[1 3 4 6 10 7 9 8 2 5]
```
```
3rd : OK
[1 3 4 6 10 7 9 8 2 5]
```

**5th**  
정렬이 완료될 때 까지 반복한다.
```
1 2 3 4 5 6 7 8 9 10
```
<br>

이 로직에서 중요한 것은 이 과정을 `n번째`에 수행 할 때 `n번째` 원소의 숫자가 정해진다.

코드를 구현해 보자.
```
   public int[] insertSort(int[] array) {
        int temp;

        // 원소 이동(반복회수 설정)
        for (int i = 0; i < array.length; i++) {
            int j = i;
            // 해당 원소의 앞 구간이 정렬이 완전히 될 때 까지 숫자를 비교하는 구간
            while (j > 0 && array[j - 1] > array[j]) {
                temp = array[j - 1];
                array[j - 1] = array[j];
                array[j] = temp;
                j--;
            }
        }
        return array;
    }
```
***
### 4. 퀵정렬
* 이때까지 배운 정렬들은 데이터량이 조금만 많아져도 사용하기가 매우 어려움. 이를 위한 빠른 정렬 알고리즘을 개발
* N^2인 것을 반반씩 나누었기 때문에 반복이 획기적으로 줄어든다. (분할 정복 방법)
  ```
  1 2 3 4 5  6 7 8 9 10  => 10 X 10
  1 2 3 4 5 / 6 7 8 9 10 => (5 X 5) + (5 X 5)
  ```
* 시간복잡도
    ```
    O(N*logN) 
    최악 : O(N^2)
    ```

### 로직
**Main idea**
```
특정한 값(Pivot)을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 후 나누자!
```
1. 보통 `첫번째 원소`를 피벗값으로 설정하고 사용함.  
2. 피벗보다 `큰 숫자를 왼쪽부터`, `작은 숫자를 오른쪽부터` 찾는다.  
3. 교체하는 작업 수행
    1. 작은 값의 인덱스가 큰 값의 인덱스보다 `작을 때(엇갈릴때)` **피벗과 작은 값의 위치를 바꾼다.**
    2. 작은 값의 인덱스가 큰 값의 인덱스보다 `클 때` **서로 변경**
4. **피벗의 인덱스가 변경될 때 까지 반복**
5. 피벗의 `왼쪽은 자신보다 작은 원소들`이. `오른쪽은 자신보다 큰 원소들`이 나열이 됨.
6. 이 `작은 원소들 집합`과 `큰 원소들 집합`의 `피벗이 된 적이 없는 가장 왼쪽 값`을 피벗으로 재지정
***
**1st**  
* 1st. `1`을 피벗으로 지정
* 2nd. `1`보다 큰 숫자를 왼쪽부터, 작은 숫자를 오른쪽부터 찾기.
* 3rd. `10의 인덱스(1)`가 `1의 인덱스(0)`보다 크니 엇갈린다. `피벗값`과 `1`을 바꿈.
```
1st : 1을 피벗으로 지정
[{1} 10 3 6 4 7 9 8 2 5]
```
```
2nd : 1보다 큰 숫자를 왼쪽부터 찾기 = 10 / 인덱스 = 1
      1보다 작은 숫자를 오른쪽부터 찾기 = 1 / 인덱스 = 0
[{1} 10 3 6 4 7 9 8 2 5]
```
```
3nd : 인덱스가 엇갈리니 피벗값과 1을 바꿈 (여기선 그대로)
[(1) 10 3 6 4 7 9 8 2 5]
```
**2nd**  
* 1st. 기존 피벗`1`의 왼쪽은 원소가 없고 오른쪽만 있으니 가장 왼쪽 값인 `10`을 새로운 피벗으로 지정
* 2nd. `10`보다 큰 숫자를 왼쪽부터, 작은 숫자를 오른쪽부터 찾기.
* 3rd. `10의 인덱스(1)`가 `5의 인덱스(9)`보다 작으니 `큰값`과 `작은값`을 바꿈.
* 이때 큰 값이 피벗이므로 피벗을 재설정 해야 한다.
```
1st : `10`을 새로운 피벗으로 지정
[(1) {10} 3 6 4 7 9 8 2 5]
```
```
2nd : 10보다 큰 숫자를 왼쪽부터 찾기 = 10 / 인덱스 = 1
      10보다 작은 숫자를 오른쪽부터 찾기 = 5 / 인덱스 = 9
[(1) {10} 3 6 4 7 9 8 2 5]
```
```
3nd : 엇갈리지 않으니 큰값(10)과 작은값(5)를 바꿈. 단 여기선 큰값이 피벗이므로 피벗 재설정 필요.
[(1) 5 3 6 4 7 9 8 2 (10)]
```

**3rd**  
* 1st. 기존 피벗`10`의 왼쪽에만 원소가 있으니 `5`를 새로운 피벗으로 지정 (`1`은 피벗이었다.)
* 2nd. `5`보다 큰 숫자를 왼쪽부터, 작은 숫자를 오른쪽부터 찾기.
* 3rd. `6의 인덱스(3)`가 `2의 인덱스(8)`보다 작으니 `큰값`과 `작은값`을 바꿈.
```
1st : `5`를 새로운 피벗으로 지정
[(1) {5} 3 6 4 7 9 8 2 (10)]
```
```
2nd : 5보다 큰 숫자를 왼쪽부터 찾기 = 6 / 인덱스 = 3
      5보다 작은 숫자를 오른쪽부터 찾기 = 2 / 인덱스 = 8
[(1) {5} 3 6 4 7 9 8 2 (10)]
```
```
3nd : 엇갈리지 않으니 큰값(6)과 작은값(2)를 바꿈.
[(1) {5} 3 2 4 7 9 8 6 (10)]
```
**4th**  
* 1st. 피벗은 그대로 `5`
* 2nd. `5`보다 큰 숫자를 왼쪽부터, 작은 숫자를 오른쪽부터 찾기.
* 3rd. `7의 인덱스(5)`가 `4의 인덱스(4)`보다 크니 엇갈린다. `피벗`과 `작은값`을 바꿈.
```
1st : `10`을 새로운 피벗으로 지정
[(1) {5} 3 2 4 7 9 8 6 (10)]
```
```
2nd : 5보다 큰 숫자를 왼쪽부터 찾기 = 7 / 인덱스 = 5
      5보다 작은 숫자를 오른쪽부터 찾기 = 4 / 인덱스 = 4
[(1) {5} 3 6 4 7 9 8 2 (10)]
```
```
3nd : 엇갈리니 피벗(5)와 작은값(4)를 바꿈.
[(1) 4 3 2 (5) 7 9 8 6 (10)]
```
**5th**  
* 1st. 기존 피벗`5`의 왼쪽에는 `4`를 오른쪽은 `7`을 새로운 피벗으로 지정
* 2nd. `4`보다 큰 숫자를 왼쪽부터, 작은 숫자를 오른쪽부터 찾기.
* 3rd. `7의 인덱스(5)`가 `4의 인덱스(4)`보다 크니 엇갈린다. `피벗`과 `작은값`을 바꿈.
```
1st : `10`을 새로운 피벗으로 지정
[(1) {4} 3 2 (5) {7} 9 8 6 (10)]
```
```
2nd : 왼쪽 : 4보다 큰 숫자를 왼쪽부터 찾기 = 4 / 인덱스 = 1
            4보다 작은 숫자를 오른쪽부터 찾기 = 2 / 인덱스 = 3
      오른쪽 : 7보다 큰 숫자를 왼쪽부터 찾기 = 9 / 인덱스 = 6
              7보다 작은 숫자를 오른쪽부터 찾기 = 6 / 인덱스 = 8
[(1) {4} 3 2 (5) {7} 9 8 6 (10)]
```
```
3nd : 둘다 엇갈리지 않는다. 하지만, 왼쪽은 큰숫자가 피벗이니 작은숫자와 피벗을
      오른쪽은 작은숫자와 오른쪽을 변경
[(1) 2 3 (4) (5) {7} 6 8 9 (10)]
```
**6th**  
* 반복.
```
[(1) (2) (3) (4) (5) (6) (7) (8) (9) (10)]
```

<br>

코드를 구현해 보자.
```
public int[] quickSort(int[] array, int start, int end) {

        // 원소가 1개인 경우 그대로 두기
        if (start >= end) {
            return array;
        }

        int pivot = start;  // 피벗은 첫 번째 원소
        int i = start + 1;  // 왼쪽에서 출발
        int j = end;        // 오른쪽에서 출발
        int temp = 0;

        // 엇갈릴때까지 반복
        while (i <= j) {
            // 피벗보다 큰 값이 나올때까지 탐색
            while (array[i] <= array[pivot] && i <= end) {
                i++;
            }
            // 피벗보다 작은 값이 나올때까지 탐색
            while (array[j] >= array[pivot] && j > start) {
                j--;
            }
            if (i > j) {
                // 엇갈린 상태면 피벗과 교체
                temp = array[j];
                array[j] = array[pivot];
                array[pivot] = temp;
            } else {
                // 엇갈리지 않았으면 작은값 큰값을 교체
                temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }

        // 피벗 기준으로 구역 나누기 (재귀함수)
        quickSort(array, start, j - 1);
        quickSort(array, j+1, end);

        return array;
    }
```

### 5. 병합 정렬
* 퀵정렬과 마찬가지인 `분할 정복`방법을 채택하였다.
* 퀵정렬과 달리 최악에도 `O(N*logN)`의 시간복잡도를 가진다.

### Logic
**Main idea**
```
일단 원소들을 모두 쪼갠 후 2개씩 합치면서 정렬하자.
```
* 합칠 때 `2의 배수`만큼 합친다.
* 합칠 때 합쳐지는 각 원소들의 크기를 비교하여 정렬한 후 합친다.

***

**1st**
* 1st. `1`과`10` / `3`과 `6` / `4`와 `7` / `9`와 `8` / `2`와 `5`를 합친다.
* 2nd. 각각을 정렬한다.
```
1st : 원소들을 2개씩 합친다(묶는다).
[1 10 / 3 6 / 4 7 / 9 8 / 2 5]
```
```
2nd : 2개씩 묶인 원소들을 정렬한다.
[(1 10) / (3 6) / (4 7) / (8 9) / (2 5)]
```

**2nd**
* 1st. 이제는 4개씩 묶는다.
* 2nd. 각 묶음에서 작은 수를 비교한다. 그 후 작은 수를 새로운 묶음의 첫번째 원소로 넣고 그 작은수가 있던 묶음의 인덱스를 `+1` 한다.
* 3th. 이 작업을 반복해서 원소가 4개가 있는 묶음을 만든다. 그 후 반복.
```
1st : 1과 3의 크기를 비교 후 1을 채택 후 새로운 묶음에 넣는다.
      다른 묶음들도 같은 작업 실시.
[({1} 10) ({3} 6) / ({4} 7) ({8} 9) / ({2} 5)]
[(1 ? ? ?) / (4 ? ? ?) / (2 5)]
```
```
2nd : 10과 3을 비교 후 3을 채택. 다른 묶음들도 같은 작업 실시.
[( {10}) ({3} 6) ( {7}) ({8} 9) (2 5)]
[(1 3 ? ?) / (4 7 ? ?) / (2 5)]
```
```
3nd : 계속 반복
[(1 3 6 10) / (4 7 8 9) / (2 5)]
[1 2 3 4 5 6 7 8 9 10]
```

<br>

코드를 구현해 보자. 이때 구역을 정해주는 코드와 정렬을 해주는 코드를 각각 분리해서 구현을 해야 한다.  

```
    public void mergeSort(int[] array, int start, int end) {

        if (start < end) {
            int middle = (start + end) / 2;
            // 원소를 각각 쪼개는 과정.
            mergeSort(array, start, (int) middle);
            mergeSort(array, (int) middle+1, end);
            merge(array, start, middle, end);
        }
    }
```
```
    public int[] merge(int[] array, int start, int middle, int end){
        int[] sortedArray = new int[10];
        int i = start;
        int j = middle + 1;
        int k = start;  // sortedArray의 index

        // 각 묶음 원소 크기 비교
        while (i <= middle && j <= end) {
            if (array[i] <= array[j]) {
                sortedArray[k] = array[i];
                i++;
            } else {
                sortedArray[k] = array[j];
                j++;
            }
            k++;
        }

        // 나머지 데이터 삽입.
        if (i > middle) {
            while (j <= end) {
                sortedArray[k] = array[j];
                j++;
                k++;
            }
        } else {
            while (i <= end) {
                sortedArray[k] = array[i];
                i++;
                k++;
            }
        }

        return sortedArray;
    }
```
그리고 `merge` 메소드 안의 `sortedArray`는 여기서는 `지역변수`로 설정을 해 주었지만,  
조금 더 처리시간을 줄이고 싶다면, `전역변수`로 두는것이 더 유리하다.  
여기서는 크기가 10인 배열들을 처리하고 있어, 따로 10으로 크기를 고정해 두었다.  

